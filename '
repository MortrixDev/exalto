const std = @import("std");
const r = @import("raylib");
const game = @import("game.zig");
const assets = @import("assets.zig");

const tile_size: i32 = 16;
const view_size: i32 = tile_size * 20;
var render_offset = r.Vector2{ .x = 0, .y = 0 };

pub const Renderer = struct {
    canvas: r.RenderTexture,
    atlas: r.Texture2D,

    pub fn init(allocator: *std.mem.Allocator) Renderer {
        _ = allocator;
        return Renderer {
            .canvas = r.RenderTexture.init(view_size, view_size),
            .atlas = r.loadTextureFromImage(r.loadImage("assets/atlas.png"))
        };
    }
};

pub fn render(rend: *Renderer, g: *game.Game) !void {
    render_offset = r.Vector2{
        .x = -g.camera_pos.x * tile_size + @divExact(view_size, 2),
        .y = g.camera_pos.y * tile_size + @divExact(view_size, 2)
    };

    r.beginTextureMode(rend.canvas);
    r.clearBackground(r.Color.init(0x44, 0x44, 0x44, 0xFF));
    
    for (0..g.level.height) |y| {
        for (0..g.level.width) |x| {
            r.drawTextureRec(
            rend.atlas,
            assets.TileLookup[g.level.get_tile_id(@intCast(x), @intCast(y))].uv,
            to_canvas(@floatFromInt(x), @floatFromInt(y)),
            r.Color.white
        );
        }
    }

    r.drawRectangle(to_canvas_x(g.player_pos.x), to_canvas_y(g.player_pos.y), tile_size, tile_size, r.Color.orange);

    r.endTextureMode();

    const screen_width: f32 = @floatFromInt(r.getScreenWidth());
    const screen_height: f32 = @floatFromInt(r.getScreenHeight());
    const aspect_ratio: f32 = screen_width / screen_height;

    var canvas_width: f32 = view_size;
    var canvas_height: f32 = view_size;
    var canvas_offset_x: f32 = 0;
    var canvas_offset_y: f32 = 0;

    if (aspect_ratio > 1) {
        canvas_height = view_size / aspect_ratio;
        canvas_offset_y = (view_size - canvas_height) / 2;
    } else {
        canvas_width = aspect_ratio * view_size;
        canvas_offset_x = (view_size - canvas_width) / 2;
    }

    r.beginDrawing();
    r.drawTexturePro(
        rend.canvas.texture,
        r.Rectangle.init(canvas_offset_x, canvas_offset_y, canvas_width, -canvas_height),
        r.Rectangle.init(0, 0, screen_width, screen_height),
        r.Vector2.zero(),
        0,
        r.Color.white
    );
    r.endDrawing();
}

fn to_canvas_x(x: f32) i32 {
    return @intFromFloat(@round(x * tile_size + render_offset.x - tile_size / 2));
}

fn to_canvas_y(y: f32) i32 {
    return @intFromFloat(@round(-y * tile_size + render_offset.y - tile_size / 2));
}

fn to_canvas(x: f32, y:f32) r.Vector2 {
    return r.Vector2.init(
        x * tile_size + render_offset.x - tile_size / 2,
        -y * tile_size + render_offset.y - tile_size / 2
    );
}
